{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/project-euler/problem-28-solution-in-python/","result":{"data":{"site":{"siteMetadata":{"author":"Jeff Willette"}},"authorAvatar":{"childImageSharp":{"fluid":{"tracedSVG":"data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='400'%20height='400'%20viewBox='0%200%20400%20400'%20preserveAspectRatio='none'%3e%3cpath%20d='M154%2018l-12%202c-4%202-38%203-47%201-13-3-20-1-13%202%205%202%2010%207%2010%209l1%207%201%205c-2%200-5-4-8-8l-2-4-1%203%201%205%201%203c-1%200-2-1-2-3-3-7-5%200-5%2015-1%2014%205%2024%2016%2026l6%202-5%2013c-11%2025-12%2031-15%2071v11h-3c-6%201-7%206-6%2017v17c-3%2024%201%2049%2011%2059%203%203%204%205%205%2010%206%2032%2010%2038%2037%2067%2015%2016%2017%2018%2017%2021%200%204-7%2018-10%2020-7%205-14%208-26%2010a271%20271%200%200047-1l-3-1-2-21%205%204%206%204v1c-1%200%207%206%209%206v1c-2%203-1%207%203%208%203%200%204-1%202-2l-1-2%202%201%209%201%208%201c1%202%2018%201%2018%200l-1-2-1-4-1-4-1-1c1-2%200-2-2-1-5%201-3-1%204-4l20-14%207-5%2013-12c8-7%208-7%208-4a587%20587%200%2000-4%2030c1%205-5%2012-14%2019l-3%203h43c23%200%2042%200%2041-1l-15-4-21-7-7-3c-5-2-7-3-11-9l-5-7c-1%200-1-11%201-24%201-6%202-8%205-12%2010-10%2020-30%2023-45%202-7%203-8%209-8%2019-3%2025-8%2031-28%206-16%207-25%207-43%200-19-1-24-8-28-3-2-4-2-8-1s-4%201-6-1c-3-4-7-49-5-58%202-11-2-25-10-35-4-5-5-7-3-11%203-3%202-7-2-12l-4-5c0-2-7-13-12-18s-15-11-18-11l-2-1c0-1-11-3-26-4-20-1-31-3-34-4l-27-4-15%202m-9%208l33%206c6%200%208%201%208%202l-2%202c-3%201-2%201%204%203l8%202c-1-3%203-2%2010%202l7%203-10-7-7-5c-1-2-14-5-27-5-5%200-7%200-8-2l-10-2c-6%200-8%200-6%201m-30%202l23%206c2%201%203%201%203%203-1%202%200%203%2010%204%208%200%209-1%201-3-5-1-5-3-1-3l-8-2a323%20323%200%2001-28-5M80%2047c0%206%202%2015%204%2020%203%205%203%205%202-1l-2-11%201%201c0%202%2018%2012%2023%2012%204%200%201-2-5-5-10-3-15-8-22-18-1-1-1-1-1%202m27%205c-2%201-1%202%202%204%203%201%204%202%203%203-2%204%205%207%208%204h3c3%201%203%201%203-1%200-1-9-7-18-11l-1%201m3%2043l-3%205c-4%206-5%2010-7%2021a170%20170%200%2001-5%2025l-1%202-2%2029-2%2031c-2%204-2%206-1%2012%201%207%201%2010-1%2016v3l2-3c3-2%207-4%207-2l-4%206c-6%206-6%208-3%2028%203%2024%208%2042%2016%2052a860%20860%200%200032%2033c-1-7%201-6%206%205%207%2012%2011%2016%2017%2018%209%203%209%203%2011%200%200-2%202-3%203-4%204-1%205%201%202%204-4%204-3%204%206%204%2016%200%2019-2%2032-20%209-11%2012-10%206%201-3%206-3%206%204%200l11-7c7-5%2028-28%2032-35%206-11%2014-29%2016-39%203-12%205-20%207-22l-1%2014v4l5-2%205-1-2-3c-6-8%203-12%2010-5l4%202%203-5%203-6%202-7c8-12%2010-27%204-39-3-8-4-8-6-5l-3%202%203%206c5%2012%204%2021-3%2027-10%209-11%2010-13%2010-1-1-1%200-1%202s-1%203-3%201v-8c1-8%201-8-1-14-3-7-3-10%201-17%204-8%2021-25%2026-26%204%200%204-1-1-3-4-2-4-2-9%201-7%204-22%2021-24%2028-1%207-4%209-8%205-2-2-2-3-2-15v-15c-6-11-6-10-5-23a567%20567%200%20001-34c0-13-1-16-6-21-2-3-4-4-4-3s-7%201-11-1c-10-4-30-6-63-8-40-3-53-3-55%200-1%201-1%201-2-1-1-3-3%200-3%205%200%203%206%2013%208%2013l1%201c0%203-13-1-17-5-3-4-5-10-3-13%201-3%200-5-3-5l-4-1c-2-1-2-1-4%202m4%2087l-3%202c-6%200-15%2011-10%2013l1%202h2c10-4%2012-4%2024-3%2018%201%2031%201%2032-1%202-2-1-7-7-9-4-2-6-2-14-3l-12-1h-13m107%200l-9%201c-11%200-19%202-20%204l-3%202c-3%200-4%206%200%206l3%202c3%201%2034%202%2043%200%206-1%208-1%2021%204%204%202%205%201%203-2l-1-2c2%200-3-7-9-11l-6-4h-22m-30%2019l1%202-1%201v1l1%202%202%201c1%200%201%201-1%202-6%204-6%209%200%205%203-2%205-1%203%202-2%202-3%207-2%207l3-3c4-4%209-8%2011-8s2%201%202%205v6l-5-1h-5l3%202c5%202%2033%202%2039%200l13-2c12-1%2013-2%203-4-6%200-8-1-10-3-4-3-10-5-18-7l-5-2h4c5%200%2013%203%2019%206%204%202%204%202%206%200%204-2%204-3%200-3-2%200-5%200-7-2-7-4-14-5-26-5-9%200-13-1-14-2-2-1-8-1-9%201h-1l-4-2c-2%200-3%200-2%201m-74%203l-8%204-8%203c-3%200-4%201%200%203%202%201%203%201%206-1%207-5%2013-6%2024-6l10-1c0-2-17-4-24-2m28%204c1%202%201%202-2%201h-23l-10%205c-4%202-8%204-11%204-6%202-6%203%201%203%204%200%207%200%2012%202%205%203%206%203%2021%203%2014%200%2021-1%2019-3l-4-1c-4%200-4%200-4-3%200-5%201-5%206%200%207%206%2010%205%204-2-2-3-2-4%201-1s5%200%202-4c-5-5-13-8-12-4m17%203c-3%202-4%2031-1%2035%201%201%202-1%202-17%201-20%201-19-1-18m-87%205c-3%209%201%2039%206%2043h1l1%202c1%202%201%200%201-7%200-11%200-11-3-16-4-6-6-13-5-21%201-6%200-6-1-1m69%2013c-4%202-14%203-22%202-9-2-14-2-16-1-3%201-2%202%203%202l10%202c10%203%2032-1%2032-5h-7m53%202l5%201%2011%202c8%202%2023%201%2029-1%206-3%205-3-7-2h-19c-12-2-19-2-19%200m-41%2028c-4%206-4%2013%200%2015%202%202%200%202-3%201l-5-2c-2%200-1-4%201-7%202-2%202-4%200-4s-6%205-7%208c0%203%204%208%2010%2011s9%204%209%202l4%202c6%206%2011%206%2016%202l3-2-7%201c-6%200-6%200-10-3l-6-4c-4-1-5-13-2-21%203-6%200-5-3%201m44%202l-1%201c-1-1-2%200-2%201h-1c0-2-4-1-5%201%200%203%200%203%204%202%203-1%203-1%205%201%201%203%200%206-2%206-5%200-21%206-21%208h5l5%201-3%201-1%201h7l1-4%201%201%204%202c4%200%2014-4%2011-5l-4%201h-2l1-1%204-8c0-2%201-1%206%202%2010%206%2024%2011%2030%2010%203%200%202-2%200-2l-3-1-9-3c-10-3-16-7-23-12-6-4-7-5-7-3m-61%205c-4%204-6%206-15%2011-10%206-12%209-12%2013%201%205%202%205%204%200%201-3%203-4%207-7%2011-6%2017-11%2019-18%201-3-1-2-3%201m85%2033c0%201-1%202-12%202a139%20139%200%2000-18%200c2-1%202-1%201-2-2-1-10%200-16%202h-9c-5-2-13-3-11-1%202%203%2015%204%2027%203l6-1-5%201c-7%203-18%202-29%200l-15-3-7-1c-1-1-2-1-5%201-4%203-5%205-1%204%202%200%208%204%2011%207l14%2010c15%209%2038%208%2053-3%2016-10%2020-13%2022-13%204%200%204-2-1-5s-5-3-5-1m-78%208c0%204%205%208%2010%208%202%200%202%200%201%201-2%201-2%201%202%203%207%204%2034%204%2043%200l5-4h-3c-2%201-12%202-13%201-2-1%201-2%205-2l5-2%206-1c4%200%2010-3%2010-5s-26%200-32%203h-17a358%20358%200%2000-22-2m17%2024l3%203c7%202%2030%201%2031-3h-34'%20fill='%23d3d3d3'%20fill-rule='evenodd'/%3e%3c/svg%3e","aspectRatio":1,"src":"/static/2c4c167c05e10b4e6891182058715e8e/61fd6/jeff.png","srcSet":"/static/2c4c167c05e10b4e6891182058715e8e/69585/jeff.png 200w,\n/static/2c4c167c05e10b4e6891182058715e8e/61fd6/jeff.png 256w","sizes":"(max-width: 256px) 100vw, 256px"}}},"mdx":{"frontmatter":{"title":"Project Euler: Problem 28 Solution in Python","createdAt":"2014-11-09T23:31:35.000Z","updatedAt":"2019-01-21T16:23:22.122Z","categories":["Programming","Project Euler","Python"],"images":null},"fields":{"githubLink":"https://github.com/jeffwillette/jeffwillette.github.io.src/tree/dev/data/blog/project-euler/problem-28-solution-in-python/index.mdx"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Project Euler: Problem 28 Solution in Python\",\n  \"published\": true,\n  \"createdAt\": \"2014-11-09T23:31:35.000Z\",\n  \"updatedAt\": \"2019-01-21T16:23:22.122Z\",\n  \"categories\": [\"Programming\", \"Project Euler\", \"Python\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"The Problem States\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:\\n\\n21 22 23 24 25\\n20 \\xA07 \\xA08 \\xA09 10\\n19 \\xA06 \\xA01 \\xA02 11\\n18 \\xA05 \\xA04 \\xA03 12\\n17 16 15 14 13\\n\\nIt can be verified that the sum of the numbers on the diagonals is 101.\\n\\nWhat is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?\\n\")), mdx(\"h2\", null, \"My Solution\"), mdx(\"p\", null, \"My first thought was to just build a function which filled up the square with all the numbers and then run through\\nthe diagonals and add them up. I knew there was probably an easier way, but making the computer fill up all those\\nnumbers in order seemed like a challenge and I decided to do that first. It was terribly inefficient because there is\\nobviously a pattern to how the numbers are filled in so I went back and made a more efficient solution as well.\"), mdx(\"h2\", null, \"The Efficient Solution\"), mdx(\"p\", null, \"The function adds up the corners of a square assuming that it is filled in the way the problem states. The top right\\ncorner will always just be the length x height since it will essentially \\xA0contain the area or all the numbers within\\nthe square. Then it is simply as much as taking the following\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"(side^2) + (side^2 - 1 \\xA0* side) + (side^2 - 2 * side) + (side^2 - 3 * side)\\n\")), mdx(\"p\", null, \"That will give me the sum of all four corners of a single square, counting by square number\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"(square 1 sides = 3, 5, 7, 9 square 2 sides = 13, 17, 21, 25)\\n\")), mdx(\"p\", null, \"I then made a for loop to add up all the squares for a 1001 x 1001 square.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import time\\n\\ndef square_diag(x):\\n    #x is going to be the length of the square sides\\n    y = x - 1\\n    cor_sum = 4 * x ** 2 - 6 * y # 4x^2 - 6y\\n    #This equation was simplified a lot, but it finds the sum of the four corners, given the length of one of the\\n    #sides, assuming that the square is built according to the problem\\n    #The original equation was (x ** 2) + (x ** 2 - y) + (x ** 2 - 2*y) + (x ** 2 - 3*y)\\n    return cor_sum\\n\\nsq_sz = int(input('What size square would you like to add the diagonals for? '))\\nstart_time = time.clock()\\n\\nsquare_no = int((sq_sz - 1)/2)\\ndiags = 0\\nfor i in range(1, square_no + 1):\\n    #The range had to be the actual square number, square one being the first 3x3 square after the center '1'\\n    #Because I am adding up concentric square numbers, not side lengths.\\n    x = i * 2 + 1\\n   diags += square_diag(x)\\nelse:\\n    diags += 1\\n    print('the total of the diagonals is:', diags)\\n\\nprint('finished in:', time.clock() - start_time, 'seconds')\\n\")), mdx(\"h2\", null, \"The Output\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"What size square would you like to add the diagonals for? 1001\\nthe total of the diagonals is: 669171001\\nfinished in: 0.0022070184126316205 seconds\\n\")), mdx(\"h2\", null, \"The Inefficient Solution\"), mdx(\"p\", null, \"I basically made a grid of a certain size, filled it in with all the numbers using logic and then made a couple for\\nloops to sum the diagonals. I did it will a 5 x 5 square here so you could actually see the output. With a 1001 x\\n1001 square and no printing of the square it takes about 4 seconds.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import time\\nfrom aFormulas import make_grid\\nstart_time = time.clock()\\n\\nsize = 5\\ng = make_grid(size, size)\\n\\nxlen, ylen = len(g[0]), len(g)\\nx, y = int(xlen/2), int(ylen/2)\\n# x and y will be rounded down from .5 so that will put them at the perfect index spot\\n\\ng[y][x] = 1\\nx += 1\\ng[y][x] = 2\\n# In order to save on loop logic, I did the first and second move already because they are somewhat special moves\\n\\ncurr = 2\\nfor i in range(len(g)):\\n    for j in range(len(g)):\\n        # Current number is 2, so the next number will be +1 everytime\\n        curr += 1\\n        if x < 0 and y < 0:\\n            # It got stuck on the last edges from indexerrrors so I made those go in the else loop\\n            if g[y][x - 1] != 0 and g[y + 1][x] == 0:\\n                # For when the left is solid, but down is open, move down\\n                y += 1\\n                g[y][x] = curr\\n            elif g[y - 1][x] != 0 and g[y][x - 1] == 0 and y != 0:\\n                # When up is solid, but left is open, move left\\n                x -= 1\\n                g[y][x] = curr\\n            elif g[y][x + 1] != 0 and g[y - 1][x] == 0:\\n                # When right is solid, but up is open, move up\\n                y -= 1\\n                g[y][x] = curr\\n            elif g[y + 1][x] != 0 and g[y][x + 1] == 0:\\n                # When down is solid, but right is open, move right\\n                x += 1\\n               g[y][x] = curr\\n        else:\\n            if g[y - 1][x] == 0 and y < 0:\\n                # For the last go around when going upwards, will fail when it gets to to row\\n                y -= 1\\n                g[y][x] = curr\\n            elif g[y][x + 1] == 0 and x < size - 2:\\n                # For the top row going right, will fail on the last number\\n                x += 1\\n                g[y][x] = curr\\n            else:\\n                # I had to break here, because otherwise it would keep looping for the first two numbers\\n                # This line makes the last number\\n                x += 1\\n                g[y][x] = curr\\n                break\\n\\n# Time to sum the diagonals -------------------------------------\\nfor i in g:\\n    print(i)\\n\\nx, y = 0, 0\\nfds = 0\\nfor i in range(0, size):\\n    # Forward diagonal sum\\n    fds += g[y][x]\\n    y += 1\\n    x += 1\\n\\nx, y = 0, size - 1\\nbds = 0\\nfor i in range(0, size):\\n    # Backward diagonal sum\\n    bds += g[y][x]\\n    y -= 1\\n    x += 1\\n\\nprint(fds + bds - 1)\\nprint('finished in:', time.clock() - start_time, 'seconds')\\n\")), mdx(\"h2\", null, \"The Output\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"[21, 22, 23, 24, 25]\\n[20, 7, 8, 9, 10]\\n[19, 6, 1, 2, 11]\\n[18, 5, 4, 3, 12]\\n[17, 16, 15, 14, 13]\\n101\\nfinished in: 0.00029677790706575174 seconds\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":1,"tableOfContents":{"items":[{"url":"#the-problem-states","title":"The Problem States"},{"url":"#my-solution","title":"My Solution"},{"url":"#the-efficient-solution","title":"The Efficient Solution"},{"url":"#the-output","title":"The Output"},{"url":"#the-inefficient-solution","title":"The Inefficient Solution"},{"url":"#the-output-1","title":"The Output"}]},"excerpt":"The Problem States My Solution My first thought was to just build a function which filled up the square with all the numbers and then runâ€¦"}},"pageContext":{"id":"7a56c8e2-6cc7-5a1d-bebe-7c62bc399fc4"}}}